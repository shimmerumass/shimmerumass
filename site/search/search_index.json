{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"COSDA - Configurable Open Source System for Data Acquisition","text":"<p>Welcome to the COSDA documentation. This project focuses on developing and implementing sensor technology using Shimmer wireless sensor platforms for research and development at the University of Massachusetts.</p>"},{"location":"#what-is-shimmer","title":"What is Shimmer?","text":"<p>Shimmer is a wireless sensor designed for real-time human motion analysis, environmental monitoring, and physiological measurements. </p> <p></p>"},{"location":"#hardware-components-overview","title":"Hardware Components Overview","text":"<p>The platform is designed to work with any data-collecting sensor device. In our deployment, we use Shimmer sensors as an example, but the system can be adapted to other wearable or IoT sensors that collect physiological or environmental data.</p>"},{"location":"#software-components-overview","title":"Software Components Overview","text":"<p>Our platform consists of several core software components, each with specific roles and technical responsibilities.</p>"},{"location":"#cloud-backend","title":"Cloud Backend","text":"<ul> <li>Provides a central API for uploading, downloading, and managing sensor data and metadata.  </li> <li>Receives files from the mobile app, processes and calibrates the data, and stores both raw and processed results.  </li> <li>Manages secure access to file storage and metadata for other components.  </li> <li>Groups and organizes files by device, user, and time for easy retrieval and analysis.  </li> <li>Serves as the main integration point for the web dashboard and mobile app. Rationale: Serverless architecture enables automatic scaling and cost efficiency.</li> </ul>"},{"location":"#mobile-app","title":"Mobile App","text":"<ul> <li>Collects data from wearable sensors and manages local storage of files.  </li> <li>Detects when sensors are ready to transfer data and initiates file transfer.  </li> <li>Ensures reliable transfer of files to the backend, with error handling and retries.  </li> <li>Tracks which files have been uploaded and manages uploads when a network is available.  </li> <li>Tags each file with device and time information for traceability. Rationale: Local-first design ensures data collection works offline and syncs when connected.</li> </ul>"},{"location":"#web-dashboard","title":"Web Dashboard","text":"<ul> <li>Provides a user interface for browsing, searching, and visualizing sensor data.  </li> <li>Allows users to download files, manage devices, and map devices to users or patients.  </li> <li>Supports secure login and access control for different user roles.  </li> <li>Enables bulk operations and administrative management of the system. Rationale: Web-based interface provides universal access without app installation.</li> </ul>"},{"location":"#database","title":"Database","text":"<ul> <li>Stores metadata about files, devices, users, and summary statistics for fast lookup and queries.  </li> <li>Supports grouping, searching, and validation of data sync status.  </li> <li>Keeps only summary and reference data, with large files stored separately. Rationale: NoSQL database optimized for flexible queries and high performance.</li> </ul>"},{"location":"#file-storage","title":"File Storage","text":"<ul> <li>Stores all raw and processed sensor data files.  </li> <li>Supports scalable upload and download of large datasets.  </li> <li>Provides secure, time-limited access to files for authorized users and components.  </li> <li>References to files are stored in the database for quick lookup. Rationale: Object storage provides unlimited scalability and cost-effective archiving.</li> </ul>"},{"location":"#workflow-summary","title":"Workflow Summary","text":"<ol> <li>The mobile app collects data from Shimmer sensors, transfers files, and uploads them to the cloud backend.  </li> <li>The backend decodes, calibrates, and stores data in Amazon S3 and DynamoDB.  </li> <li>The web dashboard provides researchers with tools to browse, visualize, and download data, as well as manage devices and users.  </li> <li>DynamoDB and S3 work together to provide fast metadata queries and scalable file storage.</li> </ol>"},{"location":"#quick-start","title":"Quick Start","text":"<p>Ready to get started? Check out our Getting Started guide for setup instructions and basic usage.</p>"},{"location":"#project-components","title":"Project Components","text":"<ul> <li>Shimmer Sensors: Wireless sensor nodes for data collection</li> <li>Docking Platform: Hardware interface for sensor management</li> <li>Data Processing: Software tools for analysis and visualization</li> <li>Protocol Implementation: Communication standards and APIs</li> </ul>"},{"location":"#documentation-structure","title":"Documentation Structure","text":"<ul> <li>Getting Started: Setup and installation guide</li> <li>Architecture: System design and components  </li> <li>Hardware &amp; Firmware: Shimmer sensor hardware and firmware details</li> <li>Protocol: Communication protocols and APIs</li> <li>Experiments: Experimental validation and results</li> <li>Shimmer Server UI: Web dashboard for data visualization and management</li> <li>Mobile App: Android app for docking and data sync</li> <li>Cloud Sync: Backend API for data processing and storage</li> </ul>"},{"location":"#developers-professor-guide","title":"Developers &amp; Professor Guide","text":"Principal Investigators Prof. Ivan Lee CICS, UMass Amherst Prof. Jeremy Gummeson Engineering, UMass Amherst Developers  Zhaolong Swetha Saseendran ssaseendran@umass.edu CICS, UMass Amherst"},{"location":"#community-support","title":"Community &amp; Support","text":"<p>This project is developed and maintained by the University of Massachusetts research community. For questions, issues, or contributions, please visit our GitHub repository.</p> <p>Project Status</p> <p>This project is actively under development. Documentation and features are continuously being updated.</p>"},{"location":"architecture/","title":"System Architecture","text":"<p>This document outlines the architecture of the UMass Shimmer sensor platform, including hardware components, software layers, and data flow.</p>","tags":["architecture","system-design","shimmer-sensor","subsystems"]},{"location":"architecture/#overview","title":"Overview","text":"<p>The UMass Shimmer system follows a modular architecture designed for flexibility, scalability, and ease of integration with existing research workflows.</p> <pre><code>graph TB\n    ShimmerSensors[Shimmer Sensors] --&gt; DockingStation[Docking Station]\n    DockingStation --&gt; MobileApp[Mobile App]\n    DataProcessingLayer --&gt; VisualizationLayer[Visualization Layer]\n    VisualizationLayer --&gt; ResearchApplications[Research Applications]\n    MobileApp[Mobile App] --&gt; APIGateway[API Gateway]\n    VisualizationLayer[Visualization Layer] --&gt; APIGateway[API Gateway]\n    DataProcessingLayer --&gt; APIGateway[API Gateway]</code></pre>","tags":["architecture","system-design","shimmer-sensor","subsystems"]},{"location":"architecture/#hardware-architecture","title":"Hardware Architecture","text":"","tags":["architecture","system-design","shimmer-sensor","subsystems"]},{"location":"architecture/#software-architecture","title":"Software Architecture","text":"","tags":["architecture","system-design","shimmer-sensor","subsystems"]},{"location":"architecture/#application-layers","title":"Application Layers","text":"","tags":["architecture","system-design","shimmer-sensor","subsystems"]},{"location":"architecture/#1-device-layer","title":"1. Device Layer","text":"<ul> <li>Firmware: Embedded software on Shimmer devices</li> <li>Drivers: Hardware abstraction and control</li> <li>Protocols: Communication and data transfer standards</li> </ul>","tags":["architecture","system-design","shimmer-sensor","subsystems"]},{"location":"architecture/#2-middleware-layer","title":"2. Middleware Layer","text":"<ul> <li>Connection Management: Device discovery and pairing</li> <li>Data Synchronization: Real-time and batch data handling</li> <li>Protocol Translation: Format conversion and standardization</li> </ul>","tags":["architecture","system-design","shimmer-sensor","subsystems"]},{"location":"architecture/#3-application-layer","title":"3. Application Layer","text":"<ul> <li>Research Tools: Data analysis and visualization</li> <li>Mobile Apps: Real-time monitoring and control</li> <li>Web Interface: Dashboard and configuration management</li> </ul>","tags":["architecture","system-design","shimmer-sensor","subsystems"]},{"location":"architecture/#4-integration-layer","title":"4. Integration Layer","text":"<ul> <li>APIs: RESTful and WebSocket interfaces</li> <li>SDKs: Python</li> <li>Plugins: Integration with existing research platforms</li> </ul>","tags":["architecture","system-design","shimmer-sensor","subsystems"]},{"location":"architecture/#data-flow","title":"Data Flow","text":"","tags":["architecture","system-design","shimmer-sensor","subsystems"]},{"location":"architecture/#real-time-streaming","title":"Real-time Streaming","text":"<ol> <li>Sensor Activation: Configured sensors begin data collection</li> <li>Wireless Transmission: Bluetooth streaming to receiving device</li> <li>Data Reception: Host application receives and validates data</li> <li>Processing Pipeline: Real-time analysis and visualization</li> </ol>","tags":["architecture","system-design","shimmer-sensor","subsystems"]},{"location":"architecture/#batch-processing","title":"Batch Processing","text":"<ol> <li>Data Logging: Sensors store data locally during collection</li> <li>Docking Transfer: High-speed download via docking station</li> <li>Data Validation: Integrity checking and error correction</li> <li>Analysis Pipeline: Offline processing and analysis</li> <li>Result Generation: Reports, visualizations, and exports</li> </ol>","tags":["architecture","system-design","shimmer-sensor","subsystems"]},{"location":"architecture/#scalability-considerations-in-future","title":"Scalability Considerations in Future","text":"","tags":["architecture","system-design","shimmer-sensor","subsystems"]},{"location":"architecture/#horizontal-scaling","title":"Horizontal Scaling","text":"<ul> <li>Multi-device Support: Simultaneous operation of multiple sensors</li> <li>Distributed Processing: Load balancing across processing nodes</li> <li>Cloud Integration: Scalable cloud-based analysis infrastructure</li> </ul>","tags":["architecture","system-design","shimmer-sensor","subsystems"]},{"location":"architecture/#vertical-scaling","title":"Vertical Scaling","text":"<ul> <li>Performance Optimization: Efficient algorithms and data structures</li> <li>Resource Management: Dynamic allocation of computing resources</li> <li>Caching Strategy: Intelligent data caching for improved performance</li> </ul>","tags":["architecture","system-design","shimmer-sensor","subsystems"]},{"location":"architecture/#subsystem-details","title":"Subsystem Details","text":"","tags":["architecture","system-design","shimmer-sensor","subsystems"]},{"location":"architecture/#1-android-subsystem-docking-data-sync-app","title":"1. Android Subsystem: Docking &amp; Data Sync App","text":"<p>Purpose: Automates nightly docking, data transfer, and cloud sync for Shimmer sensors. Designed for robust, unattended operation on Android devices.</p> <p>Architecture Diagram: <pre><code>graph TB\n    BluetoothScan[Bluetooth Scan] --&gt; DockingStateQuery[Docking State Query]\n    DockingStateQuery --&gt; FileTransfer[File Transfer RFCOMM]\n    FileTransfer --&gt; LocalStorage[Local Storage]\n    LocalStorage --&gt; CloudSync[Cloud Sync S3 Upload]\n    CloudSync --&gt; ErrorLogging[Error Logging Crashlytics]\n    LocalStorage --&gt; ManualSyncButton[Manual Sync Button]\n    FileTransfer --&gt; ChunkedTransfer[Chunked Transfer ACK NACK]</code></pre></p> <p>Key Features:</p> <ul> <li>Scans for up to two Shimmer devices via Bluetooth, adds to processing queue.</li> <li>Monitors docking state, queries device for RTC timestamp.</li> <li>Transfers files using chunked RFCOMM protocol with ACK/NACK and retries.</li> <li>Stamps file headers with device and system timestamps for traceability.</li> <li>Queues files for cloud sync; uploads to S3-compatible endpoint when network is available.</li> <li>Logs all operations and errors via Firebase Crashlytics.</li> <li>Manual sync and mapping controls available in UI.</li> </ul> <p>Protocol Details:</p> <ul> <li>Dock Query: App sends 0xD5 (CHECK_DOCK_STATE), receives 0xD6 (RESPONSE_DOCK_STATE), status byte, and 8-byte RTC64 timestamp (little-endian, decoded as <code>seconds = rtc64 / 32768.0</code>).</li> <li>File Transfer:<ul> <li>Initiate RFCOMM connection.</li> <li>Request file list, transfer each file in numbered chunks.</li> <li>Each chunk: chunk number, data, checksum. Waits for ACK/NACK.</li> <li>Retries on error, logs all failures.</li> <li>After transfer, files are queued for sync and uploaded to S3.</li> </ul> </li> <li>Sync Logic:<ul> <li>Checks network, uploads unsynced files to S3 endpoint.</li> <li>Marks files as synced on success, retains on failure for retry.</li> </ul> </li> </ul> <p>Codebase Highlights:</p> <ul> <li><code>DockingManager</code>: Orchestrates protocol, manages retries, timestamps.</li> <li><code>ShimmerFileTransferClient</code>: Handles RFCOMM, chunked transfer, header stamping.</li> <li><code>DockingService</code>, <code>ScanningService</code>, <code>TransferService</code>, <code>SyncService</code>: Foreground/background services for long-running ops and notifications.</li> <li><code>Broadcast Receivers</code>: For system/app events (boot, triggers).</li> <li><code>DockingTimestampModel</code>: Encapsulates RTC values per device/session.</li> </ul>","tags":["architecture","system-design","shimmer-sensor","subsystems"]},{"location":"architecture/#2-cloud-sync-backend-fastapi-s3-dynamodb","title":"2. Cloud Sync Backend (FastAPI, S3, DynamoDB)","text":"<p>Architecture &amp; Data Flow: <pre><code>graph TD\n    Upload[User/File Upload POST /upload/] --&gt; S3Raw[Raw File Storage]\n    S3Raw --&gt; Parse[Filename Parsing &amp; Metadata Extraction]\n    S3Raw --&gt; Decode[Decode and Calibrate FastAPI Python]\n    Parse --&gt; MetaExtract[Extract Device, Timestamp, Experiment]\n    Decode --&gt; JSONStore[Store Decoded Arrays as JSON]\n    Decode --&gt; MetaStore[Store Summary Metadata DynamoDB]\n    JSONStore --&gt; CombinedAPI[Combined Metadata API]\n    MetaStore --&gt; CombinedAPI\n    CombinedAPI --&gt; WebUI[Web UI API Consumer]\n    MetaStore --&gt; Mapping[Device-Patient Mapping CRUD]\n    Mapping --&gt; WebUI\n    CombinedAPI --&gt; Batch[Batch Download, Pre-signed URLs]</code></pre></p> <p>Detailed Steps:</p> <ol> <li>File Upload: User or device uploads raw sensor file via REST API (<code>POST /upload/</code>).</li> <li>Raw Storage: File is stored in an S3 bucket. Filenames are parsed to extract device ID, timestamp, and experiment metadata.</li> <li>Decoding &amp; Calibration: FastAPI backend (Python, ported from MATLAB) decodes binary data, applies calibration (offset, gain, alignment), and computes derived metrics.</li> <li>Data Storage:<ul> <li>Full decoded arrays are stored as JSON in S3 for later retrieval and analysis.</li> <li>Summary metadata (device, patient, time window, experiment) is stored in DynamoDB for fast queries.</li> </ul> </li> <li>Grouping: Records are grouped by device and patient, then split into groups where all records are within a tunable time window (default: 15s). Each group is assigned a unique <code>group_id</code> based on the earliest timestamp.</li> <li>Device-Patient Mapping: CRUD operations for device-patient mapping are handled via DynamoDB, supporting flexible assignment and lookup.</li> <li>API Endpoints:<ul> <li><code>POST /upload/</code>: Upload file</li> <li><code>GET /files/metadata/</code>: List files grouped by device/date/patient</li> <li><code>GET /files/combined-meta/</code>: Combined metadata with decoded data</li> <li><code>POST /decode-and-store/</code>: Decode file, store summary in DDB, full in S3</li> <li><code>GET /download/{filename}</code>: Download file</li> <li><code>GET /devices/unregistered</code>: List devices in S3 but not mapped</li> <li><code>GET /patients</code>: List unique patients</li> <li>...and more (see Cloud Sync README)</li> </ul> </li> <li>Batch &amp; Pre-signed Downloads: The backend provides batch download endpoints and pre-signed URLs for secure, time-limited access to files.</li> <li>Web UI Integration: The Web UI consumes the combined metadata API, supports device-patient mapping, and enables download/export features.</li> </ol>","tags":["architecture","system-design","shimmer-sensor","subsystems"]},{"location":"architecture/#3-web-ui-shimmer_server_ui","title":"3. Web UI (Shimmer_Server_UI)","text":"<p>Graph:</p> <pre><code>graph TB\n    A[API Service] --&gt; B[AG Grid Data Table]\n    B --&gt; C[Graph Button]\n    C --&gt; D[ChartJS Modal]\n    B --&gt; E[Device Patient Mapping]\n    B --&gt; H[Download Export]</code></pre> <p>Purpose: Angular-based dashboard for visualization, management, and download of Shimmer sensor data.</p> <p>Key Features:</p> <ul> <li>Query metadata and filter files by user, device, or session.</li> <li>Fetch and download decoded JSON files directly from S3.</li> <li>Supports downsampling for large datasets (6 k+ points) for improved chart readability.</li> <li>Built with Angular for modular, component-based development.</li> <li>Authentication and authorization powered by AWS Amplify User Pools.</li> </ul> <p>Architecture:</p> <ul> <li><code>src/app/comp/data-grid/</code>: AG Grid component for data display, graph buttons for Shimmer.</li> <li><code>src/app/pages/home-page/</code>: Dashboard with device/user stats, charts, and mapping UI.</li> <li><code>src/app/services/api.service.ts</code>: Handles API integration for S3 data, metadata, and decoded files.</li> </ul> <p>Data Flow:</p> <ol> <li>API fetches combined metadata from backend.</li> <li>Data displayed in AG Grid with Shimmer 1/2 columns.</li> <li>Graph button emits time-series data to parent component.</li> <li>Modal opens with Chart.js rendering time vs acceleration.</li> </ol> <p>Planned Extensions:</p> <ul> <li>Analytical dashboards for multi-sensor studies.</li> <li>Integration with external research tools and ML pipelines.</li> </ul>","tags":["architecture","system-design","shimmer-sensor","subsystems"]},{"location":"architecture/#4-data-processing-calibration-pipeline","title":"4. Data Processing &amp; Calibration Pipeline","text":"<p>Graph: <pre><code>graph TB\n    A[Raw Sensor File] --&gt; B[Header Parsing]\n    B --&gt; C[Calibration Offset Gain Align]\n    C --&gt; D[Time Sync and Correction]\n    D --&gt; F[Store Decoded Data S3]\n    D --&gt; G[Store Summary DynamoDB]</code></pre></p> <p>Read: <pre><code>1. Upload file to backend (S3).\n2. Backend decodes and calibrates data.\n3. Store full decoded arrays in S3, summary in DynamoDB.\n4. Web UI fetches and visualizes processed data.\n</code></pre></p> <p>Decoding Process:</p> <ul> <li>Binary sensor data decoding (Shimmer3 format)</li> <li>256-byte header: device info, sample rate, enabled sensors, calibration parameters</li> <li>Variable-length data packets (3-byte timestamp + sensor channels)</li> <li>Multi-channel support with raw and calibrated data:</li> <li>Accel_LN (Low-Noise Accelerometer): X, Y, Z axes</li> <li>Accel_WR (Wide-Range Accelerometer): X, Y, Z axes</li> <li>Gyro (Gyroscope): X, Y, Z axes</li> <li>Mag (Magnetometer): X, Y, Z axes</li> <li>Each channel provides both raw and calibrated (_cal) values</li> </ul> <p>Calibration Details:</p> <ul> <li>Inertial sensor calibration (offset, gain, alignment) for all axes and sensor types.</li> <li>Time synchronization with phone RTC and rollover correction</li> <li>Initial RTC sync from phone timestamp (Unix epoch)</li> <li>Output: Unix timestamps in <code>timestampCal</code>, ISO 8601 in <code>timestampReadable</code></li> </ul> <p>Computed Metrics:</p> <ul> <li><code>Accel_WR_Absolute</code>: Magnitude (\u221a(x\u00b2 + y\u00b2 + z\u00b2)) for each sample</li> <li><code>Accel_WR_VAR</code>: Range (max - min) of absolute acceleration</li> <li>UWB distance (<code>uwbDis</code>): Ultra-wideband distance readings (float, meters or device units)</li> </ul> <p>Flexible Time-Based Grouping:</p> <ul> <li>Decoded records are grouped by device and patient, then split into groups where all records are within a tunable time window (default: 15 seconds) of each other, regardless of date boundaries.</li> <li>Each group is assigned a unique <code>group_id</code> based on the earliest timestamp in the group.</li> <li>Shimmer assignment within group is based on device mapping from DynamoDB.</li> </ul> <p>Calibration and Decoding Script:</p> <ul> <li><code>shimmerCalibrate.py</code>: Direct Python port of MATLAB function with robust handling for binary decoding, dynamic channel parsing, custom 24-bit signed integer support, inertial sensor calibration, time calibration with rollover correction and smoothing.</li> <li>Outputs both Unix and ISO 8601 timestamps.</li> <li>All array math implemented using standard Python (no NumPy required).</li> <li>Optional plotting and MATLAB file export if dependencies are available.</li> </ul>","tags":["architecture","system-design","shimmer-sensor","subsystems"]},{"location":"architecture/#5-hardware-subsystem","title":"5. Hardware Subsystem","text":"","tags":["architecture","system-design","shimmer-sensor","subsystems"]},{"location":"architecture/#technology-summary","title":"Technology Summary","text":"Layer Technology Purpose Hardware Shimmer 3 Wireless Sensors Physiological and kinematic data capture Mobile App Android (Java) Docking, transfer, and sync automation Backend AWS Lambda + FastAPI (Python) Serverless decoding and APIs Storage Amazon S3 + DynamoDB Hybrid data + metadata storage Web UI Angular + Amplify Auth Visualization and management Monitoring AWS CloudWatch + Firebase Crashlytics Centralized logs and diagnostics","tags":["architecture","system-design","shimmer-sensor","subsystems"]},{"location":"cloud-sync/","title":"Cloud Sync Backend: Technical Overview","text":""},{"location":"cloud-sync/#purpose","title":"Purpose","text":"<p>The Cloud Sync backend is a Python FastAPI service that manages Shimmer sensor data uploads, decoding, calibration, and metadata storage. It integrates with AWS S3 for file storage and DynamoDB for metadata and summary metrics.</p>"},{"location":"cloud-sync/#architecture","title":"Architecture","text":"<ul> <li>main.py: FastAPI app, REST endpoints for file upload, download, metadata, and device-patient mapping.</li> <li>shimmerCalibrate.py: Decodes and calibrates Shimmer binary data, ported from MATLAB, with robust handling for sensor channels and time alignment.</li> <li>AWS S3: Stores raw and decoded sensor files.</li> <li>AWS DynamoDB: Stores file metadata, summary metrics, and device-patient mappings.</li> </ul>"},{"location":"cloud-sync/#key-technical-details","title":"Key Technical Details","text":""},{"location":"cloud-sync/#mainpy","title":"main.py","text":"<ul> <li>Defines REST endpoints for:</li> <li>File upload/download (with S3 integration)</li> <li>Grouping files by day, device, or patient</li> <li>Generating presigned URLs for secure file access</li> <li>Device-patient mapping CRUD operations</li> <li>Uses boto3 for AWS S3 and DynamoDB access</li> <li>Handles ZIP creation for batch downloads</li> <li>Uses Pydantic models for request/response validation</li> <li>Loads environment variables for configuration</li> </ul>"},{"location":"cloud-sync/#shimmercalibratepy","title":"shimmerCalibrate.py","text":"<ul> <li>Provides exact MATLAB port for decoding Shimmer3 binary files</li> <li>Handles:</li> <li>24-bit signed integer parsing (custom functions)</li> <li>Inertial sensor calibration (offset, gain, alignment matrix)</li> <li>Time calibration and rollover correction</li> <li>Output as JSON or MATLAB file</li> <li>All array math is implemented in pure Python</li> </ul>"},{"location":"cloud-sync/#example-workflow","title":"Example Workflow","text":"<ol> <li>User uploads a Shimmer .txt file via REST API</li> <li>File is stored in S3</li> <li>Decoding endpoint parses and calibrates data, stores full JSON in S3 and summary in DynamoDB</li> <li>Metadata endpoints allow searching, grouping, and downloading files</li> </ol>"},{"location":"cloud-sync/#notable-endpoints","title":"Notable Endpoints","text":"<ul> <li><code>/upload/</code> (POST): Upload sensor file</li> <li><code>/files/</code> (GET): List all files</li> <li><code>/files/metadata/</code> (GET): Grouped metadata</li> <li><code>/download/{filename}</code> (GET): Download file</li> <li><code>/file/decode/</code> (GET): Decode file</li> <li><code>/ddb/device-patient-map</code> (GET/PUT/DELETE): Device-patient mapping</li> </ul> <p>For more, see the code in <code>Cloud Sync/main.py</code> and <code>Cloud Sync/shimmerCalibrate.py</code>.</p>"},{"location":"experiments/","title":"Experimental Results","text":"<p>This page documents experimental validation and results for the COSDA  project components.</p>"},{"location":"experiments/#rtc-timing-validation","title":"RTC Timing Validation","text":"<p>Validation of real-time clock (RTC) synchronization between Shimmer devices and the Android docking app.</p>"},{"location":"experiments/#results","title":"Results","text":"<ul> <li>Timing accuracy: \u00b110 sec between docking and file collection, 1 or 2 min delay from switching on the Shimmer</li> <li>RMS error from Python Script to the original decoding MATLAB Script:</li> </ul>"},{"location":"experiments/#long-term-testing","title":"Long Term Testing","text":""},{"location":"experiments/#experiment-overview","title":"Experiment Overview","text":""},{"location":"experiments/#results_1","title":"Results","text":""},{"location":"experiments/#performance-benchmarks","title":"Performance Benchmarks","text":""},{"location":"experiments/#decoding-speed","title":"Decoding Speed","text":"<ul> <li>Average decode time: 15 seconds per file (1 CPU)</li> </ul> <ul> <li>Memory usage: &lt;100MB per operation</li> <li>CPU utilization: &lt;50% during processing</li> </ul>"},{"location":"experiments/#future-experiments","title":"Future Experiments","text":"<ul> <li>Multi-device synchronization</li> <li>Long-term battery life testing</li> <li>Network latency impact on sync operations</li> </ul>"},{"location":"getting-started/","title":"Getting Started","text":"<p>This guide provides setup instructions for the three main components of the COSDA Project: the Android docking app, the cloud API backend, and the web interface dashboard.</p>"},{"location":"getting-started/#android-docking-app","title":"Android Docking App","text":"<p>The Android app automates docking, data transfer, and cloud sync for Shimmer sensors.</p> <p>Repository: shimmerumass/shimmer-docking-android</p> <p>What it is: A Java-based Android application that handles Bluetooth communication with Shimmer devices, transfers sensor data, and syncs to cloud storage.</p> <p>How to run: 1. Clone the repository: <code>git clone https://github.com/shimmerumass/shimmer-docking-android</code> 2. Open the project in Android Studio 3. Build the <code>app</code> module 4. Ensure runtime permissions are granted (Bluetooth, location, notifications for Android 13+) 5. Run on an Android device (minimum SDK 31)</p> <p>See the repository README for detailed protocol documentation and UI guides.</p>"},{"location":"getting-started/#cloud-api-backend","title":"Cloud API Backend","text":"<p>The backend provides serverless data processing and storage APIs.</p> <p>Repository: shimmerumass/shimmer-cloud-api</p> <p>What it is: A Python FastAPI application deployed on AWS Lambda that decodes Shimmer sensor data, applies calibration, and manages storage in S3 and DynamoDB.</p> <p>How to run locally: 1. Install dependencies: <code>pip install fastapi uvicorn boto3 python-dotenv mangum pydantic</code> 2. Configure environment variables in <code>.env</code>:    <pre><code>S3_BUCKET=your-bucket-name\nDDB_TABLE=your-device-patient-db\nDDB_FILE_TABLE=your-file-db\nAWS_REGION=your-region\n</code></pre> 3. Run: <code>uvicorn main:app --reload</code></p> <p>For AWS deployment: Package dependencies and deploy to Lambda with API Gateway.</p> <p>See the repository README for API endpoints and data processing details.</p>"},{"location":"getting-started/#web-interface-dashboard","title":"Web Interface Dashboard","text":"<p>The web app for data visualization and management.</p> <p>Repository: shimmerumass/shimmer-web-ui</p> <p>What it is: An Angular-based web application with AG Grid for data tables, Chart.js for visualizations, and AWS Amplify for authentication and deployment.</p> <p>How to run: 1. Clone the repository: <code>git clone https://github.com/shimmerumass/shimmer-web-ui</code> 2. Install dependencies: <code>npm install</code> 3. Start development server: <code>ng serve</code> 4. Open http://localhost:4200 in your browser</p> <p>Prerequisites: Node.js v18+, npm v9+, Angular CLI.</p> <p>See the repository README for component details and deployment instructions.</p>"},{"location":"getting-started/#shimmer-sensor-and-firmware","title":"Shimmer Sensor and Firmware","text":""},{"location":"hardware-firmware/","title":"Shimmer Hardware and Firmware","text":""},{"location":"myapplication/","title":"Mobile App: Technical Overview","text":""},{"location":"myapplication/#purpose","title":"Purpose","text":"<p>MyApplication is an Android app that automates the nightly docking, data transfer, and cloud sync for Shimmer sensor devices. It is designed for robust, unattended operation in research and deployment settings, ensuring reliable data collection and upload to the cloud.</p>"},{"location":"myapplication/#architecture","title":"Architecture","text":"<ul> <li>DockingManager.java: Orchestrates the docking protocol, scanning, monitoring, and transitions between states. Handles device discovery, retry logic, and session management.</li> <li>ShimmerFileTransferClient.java: Manages Bluetooth RFCOMM connections and the custom binary file transfer protocol. Handles chunked transfer, ACK/NACK, and file header stamping with device/system timestamps.</li> <li>SyncService.java: Android Service that manages background file synchronization with the cloud (S3). Handles notifications, progress updates, and error handling.</li> <li>Other Services/Receivers: Includes ScanningService, TransferService, DockingService, and broadcast receivers for alarms and system events.</li> <li>Local Storage: Uses SQLite database and app-private directories to track and cache files before upload.</li> </ul>"},{"location":"myapplication/#key-technical-details","title":"Key Technical Details","text":""},{"location":"myapplication/#dockingmanagerjava","title":"DockingManager.java","text":"<ul> <li>Manages the full docking protocol:</li> <li>Scans for up to two paired Shimmer devices</li> <li>Monitors docking state and triggers file transfer</li> <li>Handles retry logic, silent backoff, and session state</li> <li>Maintains per-device timestamps and session logs</li> <li>Uses Android Bluetooth APIs and background threads</li> </ul>"},{"location":"myapplication/#shimmerfiletransferclientjava","title":"ShimmerFileTransferClient.java","text":"<ul> <li>Handles all Bluetooth RFCOMM communication</li> <li>Implements chunked file transfer with ACK/NACK and error recovery</li> <li>Stamps file headers with both Shimmer RTC64 and Android RTC32 timestamps</li> <li>Integrates with Firebase Analytics and Crashlytics for monitoring</li> <li>Provides methods for listing files, transferring, and marking as synced</li> </ul>"},{"location":"myapplication/#syncservicejava","title":"SyncService.java","text":"<ul> <li>Runs as a foreground service with notification</li> <li>Finds unsynced files, checks against S3/cloud, and uploads missing files</li> <li>Updates notifications with progress and completion status</li> <li>Uses ShimmerFileTransferClient for file operations</li> </ul>"},{"location":"myapplication/#example-workflow","title":"Example Workflow","text":"<ol> <li>App scans for paired Shimmer devices and monitors docking state</li> <li>When docked, initiates file transfer using chunked protocol</li> <li>Files are cached locally and tracked in SQLite</li> <li>When network is available, SyncService uploads files to S3 and marks them as synced</li> <li>All operations are logged and errors reported via Crashlytics</li> </ol> <p>For more, see the code in <code>MyApplication/app/src/main/java/com/example/myapplication/</code>.</p>"},{"location":"protocol/","title":"Communication Protocol","text":"<p>This document describes the communication protocols used by the UMass Shimmer sensor platform for device control, data transmission, and system integration.</p>"},{"location":"protocol/#android-docking-file-transfer-protocol","title":"Android Docking &amp; File Transfer Protocol","text":"<p>The Android app implements a robust, chunked file transfer protocol over Bluetooth RFCOMM for reliable data offload from Shimmer sensors during docking. This protocol is designed for resilience, traceability, and error recovery.</p>"},{"location":"protocol/#docking-workflow","title":"Docking Workflow","text":"<ol> <li>Device Discovery &amp; Monitoring</li> <li>The app scans for up to two paired Shimmer devices via Bluetooth RFCOMM.</li> <li>Each device is monitored for docking state (physical connection and readiness for transfer).</li> <li> <p>The app manages session state, retry logic, and transitions between scanning, monitoring, and transfer.</p> </li> <li> <p>Dock Query</p> </li> <li>When a device is docked, the app queries the device for its real-time clock (RTC) value.</li> <li>This timestamp is later stamped into the file header for traceability.</li> </ol>"},{"location":"protocol/#file-transfer-protocol-bluetooth-rfcomm","title":"File Transfer Protocol (Bluetooth RFCOMM)","text":""},{"location":"protocol/#1-connection-establishment","title":"1. Connection Establishment","text":"<ul> <li>The app creates an RFCOMM socket to the Shimmer device using a standard UUID.</li> <li>Up to 3 connection attempts are made with 1-second intervals.</li> </ul>"},{"location":"protocol/#2-file-list-request","title":"2. File List Request","text":"<ul> <li>The app sends a <code>LIST_FILES_COMMAND</code> (0xD0).</li> <li>The device responds with <code>FILE_LIST_RESPONSE</code> (0xD3) and the number of files available.</li> </ul>"},{"location":"protocol/#3-file-transfer-loop","title":"3. File Transfer Loop","text":"<ul> <li>For each file:<ul> <li>The app sends <code>TRANSFER_FILE_COMMAND</code> (0xD1).</li> <li>The device responds with <code>TRANSFER_START_PACKET</code> (0xFD), including protocol version, filename, tags, file size, chunk size, and total chunks.</li> <li>The app constructs a new filename for local storage, including device and experiment tags.</li> </ul> </li> </ul>"},{"location":"protocol/#4-chunked-data-transfer","title":"4. Chunked Data Transfer","text":"<ul> <li>The app sends <code>READY_FOR_CHUNKS_COMMAND</code> (0xD2) to signal readiness.</li> <li>The device sends file data in groups of up to 16 chunks, each as a <code>CHUNK_DATA_PACKET</code> (0xFC):<ul> <li>Each chunk includes a chunk number, size, and data.</li> <li>The app writes each chunk to the output file and logs hex data for debugging.</li> </ul> </li> <li>After each group, the app sends an ACK (<code>CHUNK_DATA_ACK</code>, 0xD4) or NACK (<code>CHUNK_DATA_NACK</code>, 0xD5) with the first chunk number and status.</li> <li>If no response is received after 2 ACK retries, the transfer is aborted and scheduled for retry.</li> </ul>"},{"location":"protocol/#5-transfer-completion","title":"5. Transfer Completion","text":"<ul> <li>After all chunks are received, the device sends a <code>TRANSFER_END_PACKET</code> (0xFE) with a status byte (0x01 for success, 0x00 for failure).</li> <li>The app marks the transfer as successful or failed, updates the local database, and logs analytics.</li> </ul>"},{"location":"protocol/#6-error-handling-recovery","title":"6. Error Handling &amp; Recovery","text":"<ul> <li>Unexpected headers, timeouts, or invalid chunks trigger retries or silent backoff.</li> <li>Incomplete files are deleted, and database entries are cleaned up.</li> <li>All errors are logged to Firebase Crashlytics for diagnostics.</li> </ul>"},{"location":"protocol/#file-header-stamping","title":"File Header Stamping","text":"<ul> <li>During transfer, the app stamps each file header with:<ul> <li>Shimmer device RTC64 (from dock query)</li> <li>Android system RTC32 (system time)</li> </ul> </li> <li>This ensures traceability and supports data integrity checks.</li> </ul> <p>The protocol is designed for reliability, with chunked transfer, ACK/NACK, retries, and error recovery. All operations are logged for monitoring and troubleshooting, ensuring accurate data transfer even in the presence of Bluetooth errors or interruptions.</p> <p>The Shimmer platform implements a layered protocol stack supporting multiple communication methods:</p> <ul> <li>Bluetooth Low Energy (BLE) for wireless sensor communication</li> <li>USB/Serial for high-speed docking station interface</li> <li>HTTP/WebSocket for web-based applications</li> <li>TCP/UDP for network-based integrations</li> </ul>"},{"location":"protocol/#sensor-data-layout","title":"Sensor Data Layout","text":"<pre><code>Accelerometer: 6 bytes (X, Y, Z as signed 16-bit)\nGyroscope:     6 bytes (X, Y, Z as signed 16-bit)  \nMagnetometer:  6 bytes (X, Y, Z as signed 16-bit)\nTemperature:   2 bytes (signed 16-bit, 0.1\u00b0C resolution)\nPressure:      3 bytes (unsigned 24-bit, Pa)\n</code></pre>"},{"location":"protocol/#restful-api-endpoints","title":"RESTful API Endpoints","text":""},{"location":"protocol/#device-management","title":"Device Management","text":"<pre><code>GET    /api/devices              # List all devices\nGET    /api/devices/{id}         # Get device details  \nPOST   /api/devices/{id}/connect # Connect to device\nDELETE /api/devices/{id}/connect # Disconnect device\n</code></pre>"},{"location":"protocol/#configuration","title":"Configuration","text":"<pre><code>GET    /api/devices/{id}/config      # Get configuration\nPUT    /api/devices/{id}/config      # Update configuration\nPOST   /api/devices/{id}/calibrate   # Start calibration\nGET    /api/devices/{id}/status      # Get device status\n</code></pre>"},{"location":"protocol/#data-access","title":"Data Access","text":"<pre><code>GET    /api/devices/{id}/data/live   # Real-time data stream\nGET    /api/devices/{id}/data/batch  # Historical data\nPOST   /api/devices/{id}/data/export # Export data formats\n</code></pre>"},{"location":"protocol/#android-docking-file-transfer-protocol-sequence-diagram","title":"Android Docking &amp; File Transfer Protocol Sequence Diagram","text":"<pre><code>sequenceDiagram\n  participant App as Android App\n  participant Device as Shimmer Device\n\n  App-&gt;&gt;Device: LIST_FILES_COMMAND (0xD0)\n  Device--&gt;&gt;App: FILE_LIST_RESPONSE (0xD3, file count)\n  loop For each file\n    App-&gt;&gt;Device: TRANSFER_FILE_COMMAND (0xD1)\n    Device--&gt;&gt;App: TRANSFER_START_PACKET (0xFD, metadata)\n    App-&gt;&gt;Device: READY_FOR_CHUNKS_COMMAND (0xD2)\n    loop For each chunk group (up to 16 chunks)\n      Device--&gt;&gt;App: CHUNK_DATA_PACKET (0xFC, chunk data)\n      App-&gt;&gt;Device: CHUNK_DATA_ACK (0xD4) or CHUNK_DATA_NACK (0xD5)\n      alt No response after 10s\n        App-&gt;&gt;Device: Resend ACK/NACK (max 2 retries)\n        alt Still no response\n          App--&gt;&gt;App: Abort transfer, schedule retry after 1 min\n        end\n      end\n    end\n    Device--&gt;&gt;App: TRANSFER_END_PACKET (0xFE, status)\n  end</code></pre>"},{"location":"shimmer-server-ui/","title":"Shimmer_Server_UI (Web Dashboard): Technical Overview","text":""},{"location":"shimmer-server-ui/#purpose","title":"Purpose","text":"<p>The Shimmer_Server_UI is an Angular-based web dashboard for managing, visualizing, and downloading Shimmer sensor data. It provides researchers and administrators with real-time access to device, patient, and file metadata, as well as interactive data visualization tools.</p>"},{"location":"shimmer-server-ui/#architecture","title":"Architecture","text":"<ul> <li>Angular 20+: Modern SPA framework</li> <li>AG Grid: For tabular display of device, patient, and file metadata</li> <li>Chart.js: For time-series visualization of sensor data</li> <li>AWS Amplify: For authentication, deployment, and S3 integration</li> <li>API Service: Handles all backend communication</li> </ul>"},{"location":"shimmer-server-ui/#key-technical-details","title":"Key Technical Details","text":""},{"location":"shimmer-server-ui/#apiservicets","title":"api.service.ts","text":"<ul> <li>Central service for all HTTP requests to the backend (Cloud Sync API)</li> <li>Methods for:</li> <li>Listing files and metadata</li> <li>Downloading files (direct and batch)</li> <li>Device-patient mapping CRUD</li> <li>Fetching decoded sensor data fields for visualization</li> <li>Uses Angular's HttpClient and RxJS Observables</li> </ul>"},{"location":"shimmer-server-ui/#data-gridts","title":"data-grid.ts","text":"<ul> <li>Implements AG Grid for displaying metadata</li> <li>Defines column groups for Shimmer 1 and Shimmer 2 (recorded time, day, accel var, MAC, etc.)</li> <li>Integrates with API service to fetch and display data</li> <li>Provides buttons for graph visualization (opens Chart.js modal)</li> <li>Handles downsampling for large datasets</li> </ul>"},{"location":"shimmer-server-ui/#component-structure","title":"Component Structure","text":"<ul> <li>comp/: Reusable UI components (data grid, header, auth, file viewer, etc.)</li> <li>pages/: Main dashboard, data ops, user ops</li> <li>services/: API integration</li> <li>assets/: Static images and resources</li> <li>environments/: Angular environment configs</li> </ul>"},{"location":"shimmer-server-ui/#example-workflow","title":"Example Workflow","text":"<ol> <li>User logs in via AWS Amplify Auth</li> <li>Dashboard loads metadata from backend via API service</li> <li>User can view, filter, and sort files/devices/patients</li> <li>Clicking graph buttons fetches decoded data and opens interactive charts</li> <li>Files can be downloaded individually or in batch (ZIP)</li> </ol> <p>For more, see the code in <code>Shimmer_Server_UI/src/app/services/api.service.ts</code> and <code>Shimmer_Server_UI/src/app/comp/data-grid/data-grid.ts</code>.</p>"}]}